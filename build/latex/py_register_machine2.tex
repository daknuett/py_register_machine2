% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig. }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }



\title{py\_register\_machine2 Documentation}
\date{December 09, 2016}
\release{0.1.0}
\author{Daniel Knuettel}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\setcounter{tocdepth}{1}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Overview}
\label{overview::doc}\label{overview:welcome-to-py-register-machine2-s-documentation}\label{overview:overview}

\section{Block Diagram of the Architecture}
\label{overview:block-diagram-of-the-architecture}
\includegraphics{{Blocks}.png}


\section{Class Diagram of the Memory Layout}
\label{overview:class-diagram-of-the-memory-layout}
\includegraphics{{Classes}.png}

(UML Diagram)


\chapter{Quickstart}
\label{quickstart::doc}\label{quickstart:quickstart}

\section{Jumping into PyRegisterMachine2}
\label{quickstart:jumping-into-pyregistermachine2}
The first thing you might want to do is to assemble some code and run it on the engine.
To do so you have to set up a \code{Processor} and the \code{Assembler}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}macine2.machines.small} \PYG{k+kn}{import} \PYG{n}{small\PYGZus{}register\PYGZus{}machine}
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.tools.assembler.assembler} \PYG{k+kn}{import} \PYG{n}{Assembler}
\PYG{n}{processor}\PYG{p}{,} \PYG{n}{rom}\PYG{p}{,} \PYG{n}{ram}\PYG{p}{,} \PYG{n}{flash} \PYG{o}{=} \PYG{n}{small\PYGZus{}register\PYGZus{}machine}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{processor}\PYG{o}{.}\PYG{n}{setup\PYGZus{}done}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\code{small\_register\_machine} returns a configured engine with 50 words ROM, 200 words RAM and 500 words Flash.
The size of a word is 64 bit.

Now you need a program, in this case we will use  simple \code{Hello, World} program:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{io} \PYG{k+kn}{import} \PYG{n}{StringIO}
\PYG{n}{asm} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi 0xa out0}
\PYG{l+s+s1}{ldi 0b1 ECR}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{stream} \PYG{o}{=} \PYG{n}{StringIO}\PYG{p}{(}\PYG{n}{asm}\PYG{p}{)}
\end{Verbatim}

This will print \code{Hello!\textbackslash{}n} to \code{sys.stdout} and stop the engine. The assembly language is KASM2.

The assembler will convert the assembly into machine code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{assembler} \PYG{o}{=} \PYG{n}{Assembler}\PYG{p}{(}\PYG{n}{processor}\PYG{p}{,} \PYG{n}{stream}\PYG{p}{)}
\PYG{n}{code} \PYG{o}{=} \PYG{n}{assembler}\PYG{o}{.}\PYG{n}{assemble}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The machine code is just a \code{list} of \code{int} objects that can be programmed to the
ROM or Flash device:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{rom}\PYG{o}{.}\PYG{n}{program}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}
\end{Verbatim}

And then the Processor will execute the program:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{processor}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

Putting it all together:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}macine2.machines.small} \PYG{k+kn}{import} \PYG{n}{small\PYGZus{}register\PYGZus{}machine}
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.tools.assembler.assembler} \PYG{k+kn}{import} \PYG{n}{Assembler}
\PYG{n}{processor}\PYG{p}{,} \PYG{n}{rom}\PYG{p}{,} \PYG{n}{ram}\PYG{p}{,} \PYG{n}{flash} \PYG{o}{=} \PYG{n}{small\PYGZus{}register\PYGZus{}machine}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{processor}\PYG{o}{.}\PYG{n}{setup\PYGZus{}done}\PYG{p}{(}\PYG{p}{)}
\PYG{k+kn}{from} \PYG{n+nn}{io} \PYG{k+kn}{import} \PYG{n}{StringIO}
\PYG{n}{asm} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi 0xa out0}
\PYG{l+s+s1}{ldi 0b1 ECR}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{n}{stream} \PYG{o}{=} \PYG{n}{StringIO}\PYG{p}{(}\PYG{n}{asm}\PYG{p}{)}
\PYG{n}{assembler} \PYG{o}{=} \PYG{n}{Assembler}\PYG{p}{(}\PYG{n}{processor}\PYG{p}{,} \PYG{n}{stream}\PYG{p}{)}
\PYG{n}{code} \PYG{o}{=} \PYG{n}{assembler}\PYG{o}{.}\PYG{n}{assemble}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{rom}\PYG{o}{.}\PYG{n}{program}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}
\PYG{n}{processor}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\section{A simple Code Loader}
\label{quickstart:a-simple-code-loader}
Usually the ROM will be too small to hold the programs you want to execute,
so those will be stored in the Flash.

To execute programs stored in the Flash one has to load them into RAM, this is done by the Code Loader(\emph{CL}) or Boot Code Loader (\emph{BCL}) stored in the ROM.

We will use the same setup like above:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}macine2.machines.small} \PYG{k+kn}{import} \PYG{n}{small\PYGZus{}register\PYGZus{}machine}
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.tools.assembler.assembler} \PYG{k+kn}{import} \PYG{n}{Assembler}
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.tools.assembler.directives} \PYG{k+kn}{import} \PYG{n}{ConvertingDirective}
\PYG{k+kn}{from} \PYG{n+nn}{io} \PYG{k+kn}{import} \PYG{n}{StringIO}

\PYG{n}{processor}\PYG{p}{,} \PYG{n}{rom}\PYG{p}{,} \PYG{n}{ram}\PYG{p}{,} \PYG{n}{flash} \PYG{o}{=} \PYG{n}{small\PYGZus{}register\PYGZus{}machine}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{processor}\PYG{o}{.}\PYG{n}{setup\PYGZus{}done}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{asm} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s1}{.set flash\PYGZus{}sec\PYGZus{}size flash\PYGZus{}sec\PYGZus{}end}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi 0xa out0}
\PYG{l+s+s1}{ldi 0b1 ECR}
\PYG{l+s+s1}{flash\PYGZus{}sec\PYGZus{}end:}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{n}{stream} \PYG{o}{=} \PYG{n}{StringIO}\PYG{p}{(}\PYG{n}{asm}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} This directive will allow you to set one word to a special value}
\PYG{c+c1}{\PYGZsh{} used to get the size of the section}
\PYG{n}{set\PYGZus{}directive} \PYG{o}{=} \PYG{n}{ConvertingDirective}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.set}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{)}

\PYG{n}{assembler} \PYG{o}{=} \PYG{n}{Assembler}\PYG{p}{(}\PYG{n}{processor}\PYG{p}{,} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{directives} \PYG{o}{=} \PYG{p}{[}\PYG{n}{set\PYGZus{}directive}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{code} \PYG{o}{=} \PYG{n}{assembler}\PYG{o}{.}\PYG{n}{assemble}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

The only new part is the size of the program, stored in the first word, now we will store the program in the Flash:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{flash}\PYG{o}{.}\PYG{n}{program}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}
\end{Verbatim}

So now we need the \emph{CL}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cl} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s1}{ldi 0 r0}
\PYG{l+s+s1}{in r0 r1}
\PYG{l+s+s1}{ldi RAMEND\PYGZus{}LOW r2}

\PYG{l+s+s1}{loop:}
\PYG{l+s+s1}{inc r0}
\PYG{l+s+s1}{in r0 r3}
\PYG{l+s+s1}{pst r3 r2}
\PYG{l+s+s1}{inc r2}
\PYG{l+s+s1}{dec r1}
\PYG{l+s+s1}{jne r1 loop}

\PYG{l+s+s1}{sjmp RAMEND\PYGZus{}LOW}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\end{Verbatim}

What does that code snippet?

At first it reads the size of the code section in the Flash device:

\begin{Verbatim}[commandchars=\\\{\}]
ldi 0 r0
in r0 r1
\end{Verbatim}

and sets up a pointer to the RAM word to write into:

\begin{Verbatim}[commandchars=\\\{\}]
ldi RAMEND\PYGZus{}LOW r2
\end{Verbatim}

After that it copies the content from the Flash to the RAM using a do-while-loop. Finally it jumps to the first word in RAM:

\begin{Verbatim}[commandchars=\\\{\}]
sjmp RAMEND\PYGZus{}LOW
\end{Verbatim}

The constant \code{RAMEND\_LOW} is a processor constant and points to the first word of the RAM.
You are able to generate jump marks using \code{\textless{}name\textgreater{}:} (i.e. \code{loop:}).

Now you need to assemble and store the Code Loader:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{stream} \PYG{o}{=} \PYG{n}{StringIO}\PYG{p}{(}\PYG{n}{cl}\PYG{p}{)}
\PYG{n}{assembler} \PYG{o}{=} \PYG{n}{Assembler}\PYG{p}{(}\PYG{n}{processor}\PYG{p}{,} \PYG{n}{stream}\PYG{p}{)}
\PYG{n}{code} \PYG{o}{=} \PYG{n}{assembler}\PYG{o}{.}\PYG{n}{assemble}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{rom}\PYG{o}{.}\PYG{n}{program}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}
\end{Verbatim}

And run it:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{processor}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}

\textbf{Putting it all together}:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}macine2.machines.small} \PYG{k+kn}{import} \PYG{n}{small\PYGZus{}register\PYGZus{}machine}
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.tools.assembler.assembler} \PYG{k+kn}{import} \PYG{n}{Assembler}
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.tools.assembler.directives} \PYG{k+kn}{import} \PYG{n}{ConvertingDirective}
\PYG{k+kn}{from} \PYG{n+nn}{io} \PYG{k+kn}{import} \PYG{n}{StringIO}

\PYG{n}{processor}\PYG{p}{,} \PYG{n}{rom}\PYG{p}{,} \PYG{n}{ram}\PYG{p}{,} \PYG{n}{flash} \PYG{o}{=} \PYG{n}{small\PYGZus{}register\PYGZus{}machine}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{processor}\PYG{o}{.}\PYG{n}{setup\PYGZus{}done}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{asm} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s1}{.set flash\PYGZus{}sec\PYGZus{}size flash\PYGZus{}sec\PYGZus{}end}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{H}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{e}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{l}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{o}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi }\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{!}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ out0}
\PYG{l+s+s1}{ldi 0xa out0}
\PYG{l+s+s1}{ldi 0b1 ECR}
\PYG{l+s+s1}{flash\PYGZus{}sec\PYGZus{}end:}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{n}{stream} \PYG{o}{=} \PYG{n}{StringIO}\PYG{p}{(}\PYG{n}{asm}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} This directive will allow you to set one word to a special value}
\PYG{c+c1}{\PYGZsh{} used to get the size of the section}
\PYG{n}{set\PYGZus{}directive} \PYG{o}{=} \PYG{n}{ConvertingDirective}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{.set}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{k}{lambda} \PYG{n}{x}\PYG{p}{:} \PYG{n}{x}\PYG{p}{)}

\PYG{n}{assembler} \PYG{o}{=} \PYG{n}{Assembler}\PYG{p}{(}\PYG{n}{processor}\PYG{p}{,} \PYG{n}{stream}\PYG{p}{,} \PYG{n}{directives} \PYG{o}{=} \PYG{p}{[}\PYG{n}{set\PYGZus{}directive}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{code} \PYG{o}{=} \PYG{n}{assembler}\PYG{o}{.}\PYG{n}{assemble}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{flash}\PYG{o}{.}\PYG{n}{program}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}

\PYG{n}{cl} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s1}{ldi 0 r0}
\PYG{l+s+s1}{in r0 r1}
\PYG{l+s+s1}{ldi RAMEND\PYGZus{}LOW r2}

\PYG{l+s+s1}{loop:}
\PYG{l+s+s1}{inc r0}
\PYG{l+s+s1}{in r0 r3}
\PYG{l+s+s1}{pst r3 r2}
\PYG{l+s+s1}{inc r2}
\PYG{l+s+s1}{dec r1}
\PYG{l+s+s1}{jne r1 loop}

\PYG{l+s+s1}{sjmp RAMEND\PYGZus{}LOW}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}

\PYG{n}{stream} \PYG{o}{=} \PYG{n}{StringIO}\PYG{p}{(}\PYG{n}{cl}\PYG{p}{)}
\PYG{n}{assembler} \PYG{o}{=} \PYG{n}{Assembler}\PYG{p}{(}\PYG{n}{processor}\PYG{p}{,} \PYG{n}{stream}\PYG{p}{)}
\PYG{n}{code} \PYG{o}{=} \PYG{n}{assembler}\PYG{o}{.}\PYG{n}{assemble}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{rom}\PYG{o}{.}\PYG{n}{program}\PYG{p}{(}\PYG{n}{code}\PYG{p}{)}
\PYG{n}{processor}\PYG{o}{.}\PYG{n}{run}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}


\chapter{py\_register\_machine2.core}
\label{core::doc}\label{core:py-register-machine2-core}

\section{Parts}
\label{core:module-py_register_machine2.core.parts}\label{core:parts}\index{py\_register\_machine2.core.parts (module)}
\textbf{py\_register\_machine2.core.parts}: Basic parts of the register machine
\index{AddressError}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.AddressError}\pysiglinewithargsret{\strong{exception }\code{py\_register\_machine2.core.parts.}\bfcode{AddressError}}{\emph{*args}}{}~\phantomsection\label{core:addresserror}\begin{quote}

raised by a device if the requested offset exceeds the size of the device
\end{quote}

\end{fulllineitems}

\index{BUS (class in py\_register\_machine2.core.parts)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.BUS}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.parts.}\bfcode{BUS}}{\emph{width=64}, \emph{debug=0}}{}~\phantomsection\label{core:bus}
\textbf{The BUS object}

A BUS object connects the Processor with one or more 
Memory alike operating devices ({\hyperref[core:worddevice]{\emph{WordDevice}}}).

Before the BUS starts working, devices can be registered, the
address spaces of the devices are organized incremental:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{d1} \PYG{o}{=} \PYG{n}{WordDevice}\PYG{p}{(}\PYG{l+m+mi}{4}\PYG{p}{)}
\PYG{n}{d2} \PYG{o}{=} \PYG{n}{WordDevice}\PYG{p}{(}\PYG{l+m+mi}{5}\PYG{p}{)}
\PYG{n}{d3} \PYG{o}{=} \PYG{n}{WordDevice}\PYG{p}{(}\PYG{l+m+mi}{19}\PYG{p}{)}

\PYG{n}{b} \PYG{o}{=} \PYG{n}{BUS}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{addr1} \PYG{o}{=} \PYG{n}{b}\PYG{o}{.}\PYG{n}{register\PYGZus{}device}\PYG{p}{(}\PYG{n}{d1}\PYG{p}{)}
\PYG{n}{addr2} \PYG{o}{=} \PYG{n}{b}\PYG{o}{.}\PYG{n}{register\PYGZus{}device}\PYG{p}{(}\PYG{n}{d2}\PYG{p}{)}
\PYG{n}{addr3} \PYG{o}{=} \PYG{n}{b}\PYG{o}{.}\PYG{n}{register\PYGZus{}device}\PYG{p}{(}\PYG{n}{d3}\PYG{p}{)}

\PYG{k}{print}\PYG{p}{(} \PYG{p}{(}\PYG{n}{addr1}\PYG{p}{,} \PYG{n}{addr2}\PYG{p}{,} \PYG{n}{addr3}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} (0, 4, 9)}
\end{Verbatim}

Once the BUS started working (a read/write operation has been used)
BUS.register\_device will raise a BUSSetupError.
If the addresspace of the BUS is too small do hold a new device,
BUS.register\_device will raise a BUSSetupError.

The number of read/write actions can be observed by accessing the variables
\code{reads} and \code{writes}
\index{read\_word() (py\_register\_machine2.core.parts.BUS method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.BUS.read_word}\pysiglinewithargsret{\bfcode{read\_word}}{\emph{offset}}{}~\phantomsection\label{core:read-word}
Read one word from a device.
The offset is \code{device\_addr + device\_offset}, e.g.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{offset} \PYG{o}{=} \PYG{l+m+mi}{3} \PYG{c+c1}{\PYGZsh{} third word of the device}
\PYG{n}{offset} \PYG{o}{+}\PYG{o}{=} \PYG{n}{addr2}
\PYG{n}{b}\PYG{o}{.}\PYG{n}{read\PYGZus{}word}\PYG{p}{(}\PYG{n}{offset}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} reads third word of d2.}
\end{Verbatim}

Truncates the value according to \code{width}.

May raise {\hyperref[core:buserror]{\emph{BUSError}}}, if the offset exceeds the address space.

\end{fulllineitems}

\index{register\_device() (py\_register\_machine2.core.parts.BUS method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.BUS.register_device}\pysiglinewithargsret{\bfcode{register\_device}}{\emph{word\_device}}{}~\phantomsection\label{core:register-device}
Register the {\hyperref[core:worddevice]{\emph{WordDevice}}} \code{word\_device} in the bus
returns the start address of the device.

raises: {\hyperref[core:bussetuperror]{\emph{BUSSetupError}}}, if the device cannot be registered.

\end{fulllineitems}

\index{write\_word() (py\_register\_machine2.core.parts.BUS method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.BUS.write_word}\pysiglinewithargsret{\bfcode{write\_word}}{\emph{offset}, \emph{word}}{}~\phantomsection\label{core:write-word}
Writes one word from a device,
see {\hyperref[core:read\string-word]{\emph{read\_word}}}.

\end{fulllineitems}


\end{fulllineitems}

\index{BUSError}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.BUSError}\pysiglinewithargsret{\strong{exception }\code{py\_register\_machine2.core.parts.}\bfcode{BUSError}}{\emph{*args}}{}~\phantomsection\label{core:buserror}\begin{quote}

raised by a BUS if an operation failed.
\end{quote}

\end{fulllineitems}

\index{BUSSetupError}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.BUSSetupError}\pysiglinewithargsret{\strong{exception }\code{py\_register\_machine2.core.parts.}\bfcode{BUSSetupError}}{\emph{*args}}{}~\phantomsection\label{core:bussetuperror}\begin{quote}

raised by a BUS if the setup failed.
\end{quote}

\end{fulllineitems}

\index{Integer (class in py\_register\_machine2.core.parts)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.Integer}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.parts.}\bfcode{Integer}}{\emph{value=0}, \emph{width=64}}{}~\phantomsection\label{core:integer}
The register machine may have a special width.
This is handled by the Integer objects.

Automatically truncates the value to the defined width.

Use {\hyperref[core:setvalue]{\emph{setvalue}}} and {\hyperref[core:getvalue]{\emph{getvalue}}} or {\hyperref[core:setuvalue]{\emph{setuvalue}}} and {\hyperref[core:getuvalue]{\emph{getuvalue}}} to access the value.

Uses a bitset internally.
\index{getuvalue() (py\_register\_machine2.core.parts.Integer method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.Integer.getuvalue}\pysiglinewithargsret{\bfcode{getuvalue}}{}{}~\phantomsection\label{core:getuvalue}
Get the unsigned value of the Integer, truncate it and handle Overflows.

\end{fulllineitems}

\index{getvalue() (py\_register\_machine2.core.parts.Integer method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.Integer.getvalue}\pysiglinewithargsret{\bfcode{getvalue}}{}{}~\phantomsection\label{core:getvalue}
Get the signed value of the Integer, truncate it and handle Overflows.

\end{fulllineitems}

\index{setuvalue() (py\_register\_machine2.core.parts.Integer method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.Integer.setuvalue}\pysiglinewithargsret{\bfcode{setuvalue}}{\emph{value}}{}~\phantomsection\label{core:setuvalue}
Set the unsigned value of the Integer.

\end{fulllineitems}

\index{setvalue() (py\_register\_machine2.core.parts.Integer method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.Integer.setvalue}\pysiglinewithargsret{\bfcode{setvalue}}{\emph{value}}{}~\phantomsection\label{core:setvalue}
Set the signed value of the Integer.

\end{fulllineitems}


\end{fulllineitems}

\index{ReadOnlyError}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.ReadOnlyError}\pysiglinewithargsret{\strong{exception }\code{py\_register\_machine2.core.parts.}\bfcode{ReadOnlyError}}{\emph{*args}}{}~\phantomsection\label{core:readonlyerror}\begin{quote}

raised by a device if it is read-only
\end{quote}

\end{fulllineitems}

\index{Register (class in py\_register\_machine2.core.parts)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.Register}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.parts.}\bfcode{Register}}{\emph{name}, \emph{width=64}}{}~\phantomsection\label{core:register}
Basically hold one value and permitt read/write operations.
There may be several subclasses, like Input/Output Register.

The name will be used by the assembler.
\index{read() (py\_register\_machine2.core.parts.Register method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.Register.read}\pysiglinewithargsret{\bfcode{read}}{}{}
Return the content of the Register,
may execute a function

\end{fulllineitems}

\index{write() (py\_register\_machine2.core.parts.Register method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.Register.write}\pysiglinewithargsret{\bfcode{write}}{\emph{value}}{}
Set the content of the Register,
may execute a function

\end{fulllineitems}


\end{fulllineitems}

\index{WordDevice (class in py\_register\_machine2.core.parts)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.WordDevice}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.parts.}\bfcode{WordDevice}}{\emph{size}, \emph{width=64}, \emph{mode=3}, \emph{debug=0}}{}~\phantomsection\label{core:worddevice}
Base Device for the register machine.
The words have the width \code{width} and are stored in an
{\hyperref[core:integer]{\emph{Integer}}} object.

Values are accessed by {\hyperref[core:read]{\emph{read}}} and {\hyperref[core:write]{\emph{write}}}
\index{read() (py\_register\_machine2.core.parts.WordDevice method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.WordDevice.read}\pysiglinewithargsret{\bfcode{read}}{\emph{offset}}{}~\phantomsection\label{core:read}
Returns the value of the memory word at \code{offset}.

Might raise {\hyperref[core:writeonlyerror]{\emph{WriteOnlyError}}}, if the device is write-only.
Might raise {\hyperref[core:addresserror]{\emph{AddressError}}}, if the offset exceeds the size of the device.

\end{fulllineitems}

\index{write() (py\_register\_machine2.core.parts.WordDevice method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.WordDevice.write}\pysiglinewithargsret{\bfcode{write}}{\emph{offset}, \emph{value}}{}~\phantomsection\label{core:write}
Writes the memory word at \code{offset} to \code{value}.

Might raise {\hyperref[core:readonlyerror]{\emph{ReadOnlyError}}}, if the device is read-only.
Might raise {\hyperref[core:addresserror]{\emph{AddressError}}}, if the offset exceeds the size of the device.

\end{fulllineitems}


\end{fulllineitems}

\index{WriteOnlyError}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.parts.WriteOnlyError}\pysiglinewithargsret{\strong{exception }\code{py\_register\_machine2.core.parts.}\bfcode{WriteOnlyError}}{\emph{*args}}{}~\phantomsection\label{core:writeonlyerror}\begin{quote}

raised by a device if it is write-only
\end{quote}

\end{fulllineitems}



\section{Memory}
\label{core:module-py_register_machine2.core.memory}\label{core:memory}\index{py\_register\_machine2.core.memory (module)}\index{BUS (class in py\_register\_machine2.core.memory)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.memory.BUS}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.memory.}\bfcode{BUS}}{\emph{width=64}, \emph{debug=0}}{}
The processor's memory BUS, its devices are ROM and RAM.

\end{fulllineitems}

\index{RAM (class in py\_register\_machine2.core.memory)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.memory.RAM}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.memory.}\bfcode{RAM}}{\emph{size}, \emph{width=64}, \emph{debug=0}}{}~\phantomsection\label{core:ram}
\textbf{The Random Access Memory Device}

By default the RAM device is filled with zeros. 
After poweron the Bootcode in the ROM might perform read/write operations on the RAM.
If the register machine is to execute programs from the Flash device, this code
has to be copied into the RAM.

\end{fulllineitems}

\index{ROM (class in py\_register\_machine2.core.memory)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.memory.ROM}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.memory.}\bfcode{ROM}}{\emph{size}, \emph{width=64}, \emph{debug=0}}{}~\phantomsection\label{core:rom}
\textbf{The Read Only Memory Device}

of the register machine stores either the boot code (for big programs) or
the complete program, if the program is really small.

The ROM is attached to the same BUS as the RAM and \textbf{always} includes the
\code{offset 0}. The Program Counter (\emph{PC}) of the Processor points to this word on powerup.

Because RAM and ROM are in the same address space the following formula defines the size of
RAM and ROM:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{addr\PYGZus{}space} \PYG{o}{=} \PYG{l+m+mi}{2} \PYG{o}{*}\PYG{o}{*} \PYG{n}{memorybus}\PYG{o}{.}\PYG{n}{width}
\PYG{n}{ram}\PYG{o}{.}\PYG{n}{size} \PYG{o}{+} \PYG{n}{rom}\PYG{o}{.}\PYG{n}{size} \PYG{o}{\PYGZlt{}} \PYG{n}{addr\PYGZus{}space}
\end{Verbatim}

A \code{write} call will raise {\hyperref[core:readonlyerror]{\emph{ReadOnlyError}}}.
\index{program() (py\_register\_machine2.core.memory.ROM method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.memory.ROM.program}\pysiglinewithargsret{\bfcode{program}}{\emph{prog}, \emph{offset=0}}{}~\phantomsection\label{core:program}
Write the content of the iterable \code{prog} starting with the optional offset \code{offset}
to the device.

Invokes {\hyperref[core:program\string-word]{\emph{program\_word}}}.

\end{fulllineitems}

\index{program\_word() (py\_register\_machine2.core.memory.ROM method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.memory.ROM.program_word}\pysiglinewithargsret{\bfcode{program\_word}}{\emph{offset}, \emph{word}}{}~\phantomsection\label{core:program-word}
Write the word \code{word} to the memory at offset \code{offset}.
Used to write the boot code.

Might raise {\hyperref[core:addresserror]{\emph{AddressError}}}, if the  offset exceeds the address space.

\end{fulllineitems}


\end{fulllineitems}



\section{Devices}
\label{core:module-py_register_machine2.core.device}\label{core:devices}\index{py\_register\_machine2.core.device (module)}
\textbf{py\_register\_machine2.core.device}: Device BUS and attached devices
\index{BUS (class in py\_register\_machine2.core.device)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.device.BUS}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.device.}\bfcode{BUS}}{\emph{width=64}, \emph{debug=0}}{}
The processor's device BUS, usually the Flash is attached to this BUS,
but there might be more devices.

\end{fulllineitems}

\index{Flash (class in py\_register\_machine2.core.device)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.device.Flash}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.device.}\bfcode{Flash}}{\emph{size}, \emph{width=64}, \emph{debug=0}}{}~\phantomsection\label{core:flash}
\textbf{The Program Flash}

If the size of the program exceeds the size of the ROM the program has to be written into
the Flash. The Flash is a Read/Write device and contains
\begin{itemize}
\item {} 
The Program

\item {} 
Constants

\item {} 
Static Variables

\end{itemize}

The Flash is a WordDevice and attached to the \code{device.BUS} .
\index{program() (py\_register\_machine2.core.device.Flash method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.device.Flash.program}\pysiglinewithargsret{\bfcode{program}}{\emph{prog}, \emph{offset=0}}{}
Write the content of the iterable \code{prog} starting with the optional offset \code{offset}
to the device.

Invokes \code{program\_word}.

\end{fulllineitems}

\index{program\_word() (py\_register\_machine2.core.device.Flash method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.device.Flash.program_word}\pysiglinewithargsret{\bfcode{program\_word}}{\emph{offset}, \emph{word}}{}
Program one word of the Flash device.
Might raise {\hyperref[core:addresserror]{\emph{AddressError}}}.

\end{fulllineitems}


\end{fulllineitems}



\section{Register}
\label{core:id1}\phantomsection\label{core:module-py_register_machine2.core.register}\index{py\_register\_machine2.core.register (module)}
\textbf{py\_register\_machine2.core.register}: Registers for the register machine
\index{BStreamIORegister (class in py\_register\_machine2.core.register)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.register.BStreamIORegister}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.register.}\bfcode{BStreamIORegister}}{\emph{name}, \emph{open\_stream\_in}, \emph{open\_stream\_out}, \emph{width=64}}{}~\phantomsection\label{core:bstreamioregister}
Works like {\hyperref[core:streamioregister]{\emph{StreamIORegister}}}, but \code{open\_stream\_in} and \code{open\_stream\_out} 
are byte streams (like \code{open("fname", "rb")}).
\begin{itemize}
\item {} 
A \code{read} operation will read \code{width // 8} bytes and convert them to one \code{int}.

\item {} 
A \code{write} operation will write \code{width // 8} bytes

\end{itemize}
\index{read() (py\_register\_machine2.core.register.BStreamIORegister method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.register.BStreamIORegister.read}\pysiglinewithargsret{\bfcode{read}}{}{}
Reads enough bytes from \code{open\_stream\_in} to fill the \code{width} 
(if available) and converts them to an \code{int}. Returns this \code{int}.

\end{fulllineitems}

\index{write() (py\_register\_machine2.core.register.BStreamIORegister method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.register.BStreamIORegister.write}\pysiglinewithargsret{\bfcode{write}}{\emph{word}}{}
Converts the \code{int} \code{word} to a \code{bytes} object and writes them to
\code{open\_stream\_out}.

See \code{int\_to\_bytes}.

\end{fulllineitems}


\end{fulllineitems}

\index{OutputRegister (class in py\_register\_machine2.core.register)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.register.OutputRegister}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.register.}\bfcode{OutputRegister}}{\emph{name}, \emph{open\_stream}, \emph{width=64}}{}~\phantomsection\label{core:outputregister}
Used to print data to the user.
The \code{write} call will convert \code{word} using \code{chr} and write
the resulting \code{str} to \code{open\_stream}.

The \code{read} call will return the last written \code{word}.

\code{open\_stream} might be a \code{file} (like \code{sys.stdout}) or an \code{io.StringIO} object.
\index{write() (py\_register\_machine2.core.register.OutputRegister method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.register.OutputRegister.write}\pysiglinewithargsret{\bfcode{write}}{\emph{word}}{}~\phantomsection\label{core:sowrite}
Write the \code{chr} representation of \code{word} to the \code{open\_stream}.

If \code{chr(word)} fails due \code{OverflowError}, a \code{"?"} will be written.

\end{fulllineitems}


\end{fulllineitems}

\index{Register (class in py\_register\_machine2.core.register)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.register.Register}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.register.}\bfcode{Register}}{\emph{name}, \emph{width=64}}{}
The basic standard register. 
Permitts read and write, does not execute any callbacks on read/write.

See also: {\hyperref[core:register]{\emph{Register}}}

\end{fulllineitems}

\index{StreamIORegister (class in py\_register\_machine2.core.register)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.register.StreamIORegister}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.register.}\bfcode{StreamIORegister}}{\emph{name}, \emph{open\_stream\_in}, \emph{open\_stream\_out}, \emph{width=64}}{}~\phantomsection\label{core:streamioregister}
Input/Output Register via streams.

The \code{open\_stream\_in} has to be readable, \code{open\_stream\_out} writeable.
\index{read() (py\_register\_machine2.core.register.StreamIORegister method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.register.StreamIORegister.read}\pysiglinewithargsret{\bfcode{read}}{}{}
Read a \code{str} from \code{open\_stream\_in} and convert it to an integer
using \code{ord}. The result will be truncated according to {\hyperref[core:integer]{\emph{Integer}}}.

\end{fulllineitems}

\index{write() (py\_register\_machine2.core.register.StreamIORegister method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.register.StreamIORegister.write}\pysiglinewithargsret{\bfcode{write}}{\emph{word}}{}
Works like {\hyperref[core:sowrite]{\emph{SOwrite}}}.

\end{fulllineitems}


\end{fulllineitems}



\section{Processor}
\label{core:module-py_register_machine2.core.processor}\label{core:processor}\index{py\_register\_machine2.core.processor (module)}\index{EnigneControlBits (class in py\_register\_machine2.core.processor)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.EnigneControlBits}\pysigline{\strong{class }\code{py\_register\_machine2.core.processor.}\bfcode{EnigneControlBits}}~\phantomsection\label{core:enignecontrolbits}
Container for the static engine controll bits.
Used by the {\hyperref[core:id2]{\emph{Processor}}} to handle his ECR.

\end{fulllineitems}

\index{Processor (class in py\_register\_machine2.core.processor)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.processor.}\bfcode{Processor}}{\emph{f\_cpu=None}, \emph{width=64}, \emph{interrupts=False}, \emph{clock\_barrier=None}, \emph{debug=0}}{}~\phantomsection\label{core:id2}
Fetches Opcodes from the ROM or RAM, decodes them and executes the commands.
\phantomsection\label{core:processor-phases}
Phases in one operation cycle:
\begin{description}
\item[{Fetch Phase}] \leavevmode
The Processor fetches the Opcode (one word) from the ROM or RAM device
according to the program counter and increases the program counter.

\item[{Decode Phase}] \leavevmode
The Processor looks up the Command to execute

\item[{Fetch Operands Phase}] \leavevmode
(optional) If requested the processor fetches the operands and increases the program counter.

\item[{Execute Phase}] \leavevmode
The Processor executes the Command.

\item[{Write Back Phase}] \leavevmode
(optional) If there is a result this result is written to a register or the RAM or a device.

\end{description}

\textbf{Special Register}
\phantomsection\label{core:pc}\phantomsection\label{core:ecr}\phantomsection\label{core:sp}\begin{enumerate}
\setcounter{enumi}{-1}
\item {} 
The first Register (index 0) is the Program Counter(PC).

\item {} 
The second Register (index 1) is the Engine Control Register (ECR) take a look at {\hyperref[core:enignecontrolbits]{\emph{EnigneControlBits}}}.

\item {} 
The third Register (index 2) is the Stack Pointer (SP) and may be used for \code{call}, \code{ret}, \code{push} and \code{pop}

\end{enumerate}
\phantomsection\label{core:internal-constants}
\textbf{Internal Constants}

Constants used by the Assembler, should be set using {\hyperref[core:setup\string-done]{\emph{setup\_done}}}
\begin{description}
\item[{\code{ROMEND\_LOW}}] \leavevmode
First word of the {\hyperref[core:rom]{\emph{ROM}}} (always \code{0})

\item[{\code{ROMEND\_HIGH} }] \leavevmode
Last word of the {\hyperref[core:rom]{\emph{ROM}}}

\item[{\code{RAMEND\_LOW}}] \leavevmode
First word of the {\hyperref[core:ram]{\emph{RAM}}}, (\code{ROMEND\_HIGH + rom.size})

\item[{\code{RAMEND\_HIGH}}] \leavevmode
Last word of the {\hyperref[core:ram]{\emph{RAM}}}

\item[{\code{FLASH\_START}}] \leavevmode
First word of the Flash\_(always \code{0})

\item[{\code{FLASH\_END}}] \leavevmode
Last word of the {\hyperref[core:flash]{\emph{Flash}}}

\item[{\emph{Interrupt Name}}] \leavevmode
Address of the interrupt (set by invoking \code{add\_interrupt})

\end{description}

\textbf{Cycles}

The number of cycles can be observed by acessing the \code{cycles} variable.
\index{add\_interrupt() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.add_interrupt}\pysiglinewithargsret{\bfcode{add\_interrupt}}{\emph{interrupt}}{}
Adds the interrupt to the internal interrupt storage \code{self.interrupts} and
registers the interrupt address in the internal constants.

\end{fulllineitems}

\index{add\_register() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.add_register}\pysiglinewithargsret{\bfcode{add\_register}}{\emph{register}}{}
Adds a new register in the {\hyperref[core:registerinterface]{\emph{RegisterInterface}}}.

Invokes {\hyperref[core:add\string-register]{\emph{add\_register}}}.

\end{fulllineitems}

\index{do\_cycle() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.do_cycle}\pysiglinewithargsret{\bfcode{do\_cycle}}{}{}~\phantomsection\label{core:do-cycle}
Run one clock cycle of the {\hyperref[core:id2]{\emph{Processor}}},
works according to {\hyperref[core:processor\string-phases]{\emph{processor\_phases}}}.

Then all \code{on\_cycle\_callbacks} are executed and the internal Registers are updated.

If \code{f\_cpu} is set and the execution took not long enough,
\code{do\_cycle} will wait until the right time for the next cycle.

If \code{clock\_barrier} is set, \code{do\_cycle} will perform the \code{clock\_barrier.wait()}.

Might raise {\hyperref[core:sigsegv]{\emph{SIGSEGV}}}, if there is an invalid opcode.

\end{fulllineitems}

\index{en\_dis\_able\_interrupts() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.en_dis_able_interrupts}\pysiglinewithargsret{\bfcode{en\_dis\_able\_interrupts}}{\emph{mask}}{}
This callback might be used by a Register to enable/disable Interrupts.

\code{mask} is an \code{int}, the Interrupts are bits in this mask, the first registered interrupt
has the bit \code{(1 \textless{}\textless{} 0)}, the n-th Interrupt the bit \code{(1 \textless{}\textless{} (n - 1))}.
If the bit is cleared (\code{0}) the Interrupt will be disabled.

\end{fulllineitems}

\index{interrupt() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.interrupt}\pysiglinewithargsret{\bfcode{interrupt}}{\emph{address}}{}
Interrupts the Processor and forces him to jump to \code{address}.
If \code{push\_pc} is enabled this will push the PC to the stack.

\end{fulllineitems}

\index{register\_command() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.register_command}\pysiglinewithargsret{\bfcode{register\_command}}{\emph{command}}{}~\phantomsection\label{core:register-command}
Register a Command in the Processor,
the Command can now be executed by the Processor.

\end{fulllineitems}

\index{register\_device() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.register_device}\pysiglinewithargsret{\bfcode{register\_device}}{\emph{device}}{}
Registers a device in the device {\hyperref[core:bus]{\emph{BUS}}}.

Invokes {\hyperref[core:register\string-device]{\emph{register\_device}}}.

\end{fulllineitems}

\index{register\_memory\_device() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.register_memory_device}\pysiglinewithargsret{\bfcode{register\_memory\_device}}{\emph{device}}{}
Registers a device in the memory {\hyperref[core:bus]{\emph{BUS}}}.

Invokes {\hyperref[core:register\string-device]{\emph{register\_device}}}.

\end{fulllineitems}

\index{register\_on\_cycle\_callback() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.register_on_cycle_callback}\pysiglinewithargsret{\bfcode{register\_on\_cycle\_callback}}{\emph{callback}}{}
A on cycle callback is executed in every clock cycle of the
Processor. No on cycle callback modifies the state of the Processor directly,
but it might cause an Interrupt.

The on cycle callback is a function without arguments:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{on\PYGZus{}cycle\PYGZus{}callback}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{One cycle done}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{Verbatim}

The return value of a callback is ignored and the callback must not raise Exceptions,
but fatal Errors may stop the engine.

\end{fulllineitems}

\index{reset() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.reset}\pysiglinewithargsret{\bfcode{reset}}{}{}
Resets the control registers of the Processor\_({\hyperref[core:pc]{\emph{PC}}}, {\hyperref[core:ecr]{\emph{ECR}}} and {\hyperref[core:sp]{\emph{SP}}})

\end{fulllineitems}

\index{run() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.run}\pysiglinewithargsret{\bfcode{run}}{}{}
Runs {\hyperref[core:do\string-cycle]{\emph{do\_cycle}}}, until either a stop bit in the {\hyperref[core:ecr]{\emph{ECR}}} is set (see {\hyperref[core:enignecontrolbits]{\emph{EnigneControlBits}}}),
or if an Exception in {\hyperref[core:do\string-cycle]{\emph{do\_cycle}}} occurs.

\end{fulllineitems}

\index{setup\_done() (py\_register\_machine2.core.processor.Processor method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.Processor.setup_done}\pysiglinewithargsret{\bfcode{setup\_done}}{}{}~\phantomsection\label{core:setup-done}
Finish the setup of the Processor.

This should be the last call before the Processor is used.
Sets the {\hyperref[core:internal\string-constants]{\emph{internal constants}}} (used by the assembler) and
sets the Stack Pointer to RAMEND\_HIGH, if there is a RAM attached.
If there is no RAM attached, SP will stay \code{0}.

If there is a RAM attached \code{push\_pc} is set.

Might raise {\hyperref[core:setuperror]{\emph{SetupError}}}.

\end{fulllineitems}


\end{fulllineitems}

\index{RegisterInterface (class in py\_register\_machine2.core.processor)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.RegisterInterface}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.processor.}\bfcode{RegisterInterface}}{\emph{registers={[}{]}}, \emph{debug=0}, \emph{width=64}}{}~\phantomsection\label{core:registerinterface}
Used by the Processor to perform read/write
operations on the registers.
\index{add\_register() (py\_register\_machine2.core.processor.RegisterInterface method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.RegisterInterface.add_register}\pysiglinewithargsret{\bfcode{add\_register}}{\emph{register}}{}~\phantomsection\label{core:add-register}
Adds the {\hyperref[core:register]{\emph{Register}}} \code{register} to the interface.

Will raise a {\hyperref[core:setuperror]{\emph{SetupError}}} if the interface is locked (because it is running) or if
there is already a Register with the name of the new Register or if
the number of Registers would exceed the size of the interface.

Returns the index of the new Register

\end{fulllineitems}

\index{read() (py\_register\_machine2.core.processor.RegisterInterface method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.RegisterInterface.read}\pysiglinewithargsret{\bfcode{read}}{\emph{name\_or\_index}}{}
Read a word from the Register with the name \code{name\_or\_index} or with the index \code{name\_or\_index}.
\code{name\_or\_index} hat to be either \code{str} or \code{int}. If the type of \code{name\_or\_index}
is wrong an AttributeError will be raised.

If there is no Register with the specified name or index, a NameError will be raised.

\end{fulllineitems}

\index{write() (py\_register\_machine2.core.processor.RegisterInterface method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.RegisterInterface.write}\pysiglinewithargsret{\bfcode{write}}{\emph{name\_or\_index}, \emph{word}}{}
Write a word in the Register with the name \code{name\_or\_index} or with the index \code{name\_or\_index}.
\code{name\_or\_index} hat to be either \code{str} or \code{int}. If the type of \code{name\_or\_index}
is wrong an AttributeError will be raised.

If there is no Register with the specified name or index, a NameError will be raised.

\end{fulllineitems}


\end{fulllineitems}

\index{SIGSEGV}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.SIGSEGV}\pysiglinewithargsret{\strong{exception }\code{py\_register\_machine2.core.processor.}\bfcode{SIGSEGV}}{\emph{*args}}{}~\phantomsection\label{core:sigsegv}
Raised if an invalid memory command or opcode occurs.

\end{fulllineitems}

\index{SetupError}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.processor.SetupError}\pysiglinewithargsret{\strong{exception }\code{py\_register\_machine2.core.processor.}\bfcode{SetupError}}{\emph{*args}}{}~\phantomsection\label{core:setuperror}
Raised if the setup is invalid.

\end{fulllineitems}



\section{Commands}
\label{core:commands}\label{core:module-py_register_machine2.core.commands}\index{py\_register\_machine2.core.commands (module)}
\textbf{py\_register\_machine2.core.commands}: Abstract Commands
\index{ArithmeticCommand (class in py\_register\_machine2.core.commands)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.commands.ArithmeticCommand}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.commands.}\bfcode{ArithmeticCommand}}{\emph{mnemonic}, \emph{opcode}, \emph{function}}{}~\phantomsection\label{core:arithmeticcommand}
Used for calculation commands, \code{numargs} is always 2,
both arguments are Registers.

\emph{Example}: The \code{add} command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{add\PYGZus{}function} \PYG{o}{=} \PYG{k}{lambda} \PYG{n}{a}\PYG{p}{,}\PYG{n}{b}\PYG{p}{:} \PYG{n}{a}\PYG{o}{+}\PYG{n}{b}
\PYG{n}{add\PYGZus{}command} \PYG{o}{=} \PYG{n}{ArithmeticCommand}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{add}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{add\PYGZus{}function}\PYG{p}{)}
\end{Verbatim}
\index{exec() (py\_register\_machine2.core.commands.ArithmeticCommand method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.commands.ArithmeticCommand.exec}\pysiglinewithargsret{\bfcode{exec}}{\emph{operand1}, \emph{operand2}}{}
Uses two operands and performs a function on their content.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{operand1} \PYG{o}{=} \PYG{n}{function}\PYG{p}{(}\PYG{n}{operand1}\PYG{p}{,} \PYG{n}{operand2}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}


\end{fulllineitems}

\index{BaseCommand (class in py\_register\_machine2.core.commands)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.commands.BaseCommand}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.commands.}\bfcode{BaseCommand}}{\emph{mnemonic}, \emph{opcode}, \emph{numargs}, \emph{argtypes}}{}
The base class for Commands.

Every Command has to be derived from BaseCommand and provide the following functions:
\begin{itemize}
\item {} 
{\hyperref[core:exec]{\emph{exec}}}

\item {} 
{\hyperref[core:numargs]{\emph{numargs}}}

\item {} 
{\hyperref[core:mnemonic]{\emph{mnemonic}}}

\item {} 
{\hyperref[core:opcode]{\emph{opcode}}}

\item {} 
{\hyperref[core:argtypes]{\emph{argtypes}}}

\end{itemize}
\index{argtypes() (py\_register\_machine2.core.commands.BaseCommand method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.commands.BaseCommand.argtypes}\pysiglinewithargsret{\bfcode{argtypes}}{}{}~\phantomsection\label{core:argtypes}
Return a list of strings defining the argument types,
i.e.:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{register}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{register}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}
\end{Verbatim}

\end{fulllineitems}

\index{exec() (py\_register\_machine2.core.commands.BaseCommand method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.commands.BaseCommand.exec}\pysiglinewithargsret{\bfcode{exec}}{\emph{*args}}{}~\phantomsection\label{core:exec}
Exec will execute the Action of the Command.
The method will be provided with {\hyperref[core:numargs]{\emph{numargs}}} arguments and
might read/write data via the attributes \code{register\_interface},
\code{membus} and \code{devbus} provided once the Command is registered in the {\hyperref[core:id2]{\emph{Processor}}} 
using {\hyperref[core:register\string-command]{\emph{register\_command}}}.

\end{fulllineitems}

\index{mnemonic() (py\_register\_machine2.core.commands.BaseCommand method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.commands.BaseCommand.mnemonic}\pysiglinewithargsret{\bfcode{mnemonic}}{}{}~\phantomsection\label{core:mnemonic}
Returns the mnemonic of the command (\code{str}).
Used by the Assembler and Disassembler.

\end{fulllineitems}

\index{numargs() (py\_register\_machine2.core.commands.BaseCommand method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.commands.BaseCommand.numargs}\pysiglinewithargsret{\bfcode{numargs}}{}{}~\phantomsection\label{core:numargs}
Returns the number of needed arguments.
Used in the \code{fetch-operands-phase}.

\end{fulllineitems}

\index{opcode() (py\_register\_machine2.core.commands.BaseCommand method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.commands.BaseCommand.opcode}\pysiglinewithargsret{\bfcode{opcode}}{}{}~\phantomsection\label{core:opcode}
Returns the opcode of the command (\code{int}).
Used by the Assembler and in the \code{decode-command-phase}.

\end{fulllineitems}


\end{fulllineitems}

\index{FunctionCommand (class in py\_register\_machine2.core.commands)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.commands.FunctionCommand}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.commands.}\bfcode{FunctionCommand}}{\emph{mnemonic}, \emph{opcode}, \emph{numargs}, \emph{function}, \emph{argtypes}}{}~\phantomsection\label{core:functioncommand}
Provides a basic handle to create Commands.

The argument \code{function} is a function with at least three arguments:
\begin{enumerate}
\item {} 
\code{register\_interface}

\item {} 
\code{memory\_BUS}

\item {} 
\code{device\_BUS}

\end{enumerate}

The function will be able to access the Processor's {\hyperref[core:registerinterface]{\emph{RegisterInterface}}} and {\hyperref[core:bus]{\emph{BUS}}} es
through this arguments.

If the function needs any operands the number of additional arguments have to be
in \code{numargs}

For arithmetic commands (like \code{add}, \code{mul},...) see {\hyperref[core:arithmeticcommand]{\emph{ArithmeticCommand}}}.

\emph{Example}: \code{ld} Command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{ld\PYGZus{}function}\PYG{p}{(}\PYG{n}{register\PYGZus{}interface}\PYG{p}{,} \PYG{n}{memory\PYGZus{}BUS}\PYG{p}{,} \PYG{n}{device\PYGZus{}BUS}\PYG{p}{,} \PYG{n}{addr\PYGZus{}from}\PYG{p}{,} \PYG{n}{to}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{from\PYGZus{}} \PYG{o}{=} \PYG{n}{register\PYGZus{}interface}\PYG{o}{.}\PYG{n}{read}\PYG{p}{(}\PYG{n}{addr\PYGZus{}from}\PYG{p}{)}

        \PYG{n}{word} \PYG{o}{=} \PYG{n}{memory\PYGZus{}BUS}\PYG{o}{.}\PYG{n}{read\PYGZus{}word}\PYG{p}{(}\PYG{n}{from\PYGZus{}}\PYG{p}{)}
        \PYG{n}{register\PYGZus{}interface}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{to}\PYG{p}{,} \PYG{n}{word}\PYG{p}{)}

\PYG{n}{ld\PYGZus{}command} \PYG{o}{=} \PYG{n}{FunctionCommand}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ld}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{34}\PYG{p}{,} \PYG{l+m+mi}{2}\PYG{p}{,} \PYG{n}{ld\PYGZus{}function}\PYG{p}{,} \PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{const}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{register}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\emph{Example}: \code{nop} Command:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{nop\PYGZus{}function}\PYG{p}{(}\PYG{n}{register\PYGZus{}interface}\PYG{p}{,} \PYG{n}{memory\PYGZus{}BUS}\PYG{p}{,} \PYG{n}{device\PYGZus{}BUS}\PYG{p}{)}\PYG{p}{:}
        \PYG{k}{return}
\PYG{n}{nop\PYGZus{}command} \PYG{o}{=} \PYG{n}{FunctionCommand}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{nop}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+m+mi}{36}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{nop\PYGZus{}function}\PYG{p}{,} \PYG{p}{[}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}

\end{fulllineitems}



\section{Interrupts}
\label{core:module-py_register_machine2.core.interrupts}\label{core:interrupts}\index{py\_register\_machine2.core.interrupts (module)}
\textbf{py\_register\_machine2.core.interrupts}: Basic module to provide Interrupts.
\index{Autoreset (class in py\_register\_machine2.core.interrupts)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.interrupts.Autoreset}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.interrupts.}\bfcode{Autoreset}}{\emph{name}, \emph{processor}, \emph{overflow\_size}}{}~\phantomsection\label{core:autoreset}
A really rude form of the Watchdog.
This Interrupt will force the Processor to jump to offset \code{0}.

\end{fulllineitems}

\index{Counter (class in py\_register\_machine2.core.interrupts)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.interrupts.Counter}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.interrupts.}\bfcode{Counter}}{\emph{address}, \emph{name}, \emph{processor}, \emph{overflow\_size}}{}~\phantomsection\label{core:counter}
A Counter/Timer implementation.

The \code{\_\_init\_\_} method will inject an \code{on\_cycle\_callback} into the Processor.
This callback will increment the internal counter variable by one.
If the internal counter reaches a predefined value the \code{interrupt} method will be invoked.

\end{fulllineitems}

\index{Interrupt (class in py\_register\_machine2.core.interrupts)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.interrupts.Interrupt}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.core.interrupts.}\bfcode{Interrupt}}{\emph{address}, \emph{name}, \emph{processor}}{}~\phantomsection\label{core:interrupt}
The Base Class for Interrupts. 
If \code{Interrupt.interrupt} is invoked this will invoke \code{Processor.interrupt} and provide the address of the 
Interrupt.

This will allow one to place an ISR (Interrupt Service Routine) at this address.
\index{interrupt() (py\_register\_machine2.core.interrupts.Interrupt method)}

\begin{fulllineitems}
\phantomsection\label{core:py_register_machine2.core.interrupts.Interrupt.interrupt}\pysiglinewithargsret{\bfcode{interrupt}}{}{}
Will interrupt the Processor, if the Interrupt is enabled.

\end{fulllineitems}


\end{fulllineitems}



\chapter{py\_register\_machine2.commands}
\label{commands::doc}\label{commands:py-register-machine2-commands}

\section{Basic Commands}
\label{commands:basic-commands}\label{commands:module-py_register_machine2.commands.basic_commands}\index{py\_register\_machine2.commands.basic\_commands (module)}
\textbf{py\_register\_machine2.commands.basic\_commands}: The most important commands

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
mnemonic
} & \textsf{\relax 
opcode
} & \textsf{\relax 
Description
}\\
\hline
mov a b
 & 
0x01
 & 
copy content from register a to register b \protect\footnotemark[1]
\\
\hline
pld a b
 & 
0x02
 & 
load from address in register a to register b \protect\footnotemark[1]
\\
\hline
pst a b
 & 
0x03
 & 
store register a to address in register b \protect\footnotemark[1]
\\
\hline
ld  a b
 & 
0x04
 & 
load from a into register b \protect\footnotemark[1]
\\
\hline
st  a b
 & 
0x05
 & 
store from register a to address b \protect\footnotemark[1]
\\
\hline
add a b
 & 
0x06
 & 
b = a + b
\\
\hline
sub a b
 & 
0x07
 & 
b = a - b
\\
\hline
mul a b
 & 
0x08
 & 
b = a * b
\\
\hline
div a b
 & 
0x09
 & 
b = a / b (integer division)
\\
\hline
jmp a
 & 
0x0a
 & 
pc = pc + a - 2 \protect\footnotemark[3]
\\
\hline
in a b
 & 
0x0b
 & 
read from address in register a to register b \protect\footnotemark[2]
\\
\hline
out a b
 & 
0x0c
 & 
write register a to address in register b \protect\footnotemark[2]
\\
\hline
inc a
 & 
0x0d
 & 
increase register a
\\
\hline
dec a
 & 
0x0f
 & 
decrease register a
\\
\hline
jne a b
 & 
0x10
 & 
if a != 0: pc += b - 3
\\
\hline
jeq a b
 & 
0x11
 & 
if a == 0: pc += b - 3
\\
\hline
jle a b
 & 
0x12
 & 
if a \textless{}= 0: pc += b - 3
\\
\hline
jlt a b
 & 
0x13
 & 
if a \textless{} 0: pc += b - 3
\\
\hline
jge a b
 & 
0x14
 & 
if a \textgreater{}= 0: pc += b - 3
\\
\hline
jgt a b
 & 
0x15
 & 
if a \textgreater{} 0: pc += b - 3
\\
\hline
ldi a b
 & 
0x16
 & 
Load immediate a into Register b
\\
\hline
sjmp a
 & 
0x17
 & 
pc = a - 2 \protect\footnotemark[3]
\\
\hline\end{tabulary}

\footnotetext[1]{
stores and loads to/from the memory BUS
}\footnotetext[3]{
both the fetch opcode and fetch arguments increases the PC, so we need to undo this.
}\footnotetext[2]{
reads and writes from/to the device BUS
}
A list of all commands is \code{basic\_commands}.
\phantomsection\label{commands:module-py_register_machine2.commands.stack_based}\index{py\_register\_machine2.commands.stack\_based (module)}
\textbf{py\_register\_machine2.commands.stack\_based}: A bunch of stack based commands

\begin{tabulary}{\linewidth}{|L|L|L|}
\hline
\textsf{\relax 
mnemonic
} & \textsf{\relax 
opcode
} & \textsf{\relax 
Description
}\\
\hline
push a
 & 
0x18
 & 
{\color{red}\bfseries{}*}(SP--) = a
\\
\hline
pop a
 & 
0x19
 & 
a = {\color{red}\bfseries{}*}(++SP)
\\
\hline
call a
 & 
0x1a
 & 
{\color{red}\bfseries{}*}(SP--) = PC; PC += a
\\
\hline
scall a
 & 
0x1b
 & 
{\color{red}\bfseries{}*}(SP--) = PC; PC = a
\\
\hline
ret
 & 
0x1c
 & 
PC = {\color{red}\bfseries{}*}(++SP)
\\
\hline\end{tabulary}


all stackbased commands are available in the list \code{stack\_based\_commands}.


\chapter{py\_register\_machine2.machines}
\label{machines:py-register-machine2-machines}\label{machines::doc}
A collection of register machines in different states of configuration.


\section{Small Machines}
\label{machines:module-py_register_machine2.machines.small}\label{machines:small-machines}\index{py\_register\_machine2.machines.small (module)}
\textbf{py\_register\_machine2.machines.small}: a collection of small ready to use register machines

\textbf{About Register Machine Definitions}

All Register Machine Definitions are functions that take at least \code{0} arguments and return
a \code{tuple} with length \code{4}: \code{(Processor, ROM, RAM, Flash)}

\emph{Example}: a simple Register Machine:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.core} \PYG{k+kn}{import} \PYG{n}{memory}\PYG{p}{,} \PYG{n}{processor}\PYG{p}{,} \PYG{n}{register}\PYG{p}{,} \PYG{n}{device}
\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.commands.basic\PYGZus{}commands} \PYG{k+kn}{import} \PYG{n}{basic\PYGZus{}commands}
\PYG{k}{def} \PYG{n+nf}{simple\PYGZus{}register\PYGZus{}machine}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{rom} \PYG{o}{=} \PYG{n}{memory}\PYG{o}{.}\PYG{n}{ROM}\PYG{p}{(}\PYG{l+m+mi}{60}\PYG{p}{)}
        \PYG{n}{ram} \PYG{o}{=} \PYG{n}{memory}\PYG{o}{.}\PYG{n}{RAM}\PYG{p}{(}\PYG{l+m+mi}{70}\PYG{p}{)}
        \PYG{n}{flash} \PYG{o}{=} \PYG{n}{device}\PYG{o}{.}\PYG{n}{Flash}\PYG{p}{(}\PYG{l+m+mi}{300}\PYG{p}{)}

        \PYG{n}{proc} \PYG{o}{=} \PYG{n}{processor}\PYG{o}{.}\PYG{n}{Processor}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{proc}\PYG{o}{.}\PYG{n}{register\PYGZus{}memory\PYGZus{}device}\PYG{p}{(}\PYG{n}{rom}\PYG{p}{)}
        \PYG{n}{proc}\PYG{o}{.}\PYG{n}{register\PYGZus{}memory\PYGZus{}device}\PYG{p}{(}\PYG{n}{ram}\PYG{p}{)}
        \PYG{n}{proc}\PYG{o}{.}\PYG{n}{register\PYGZus{}device}\PYG{p}{(}\PYG{n}{flash}\PYG{p}{)}

        \PYG{n}{r0} \PYG{o}{=} \PYG{n}{register}\PYG{o}{.}\PYG{n}{Register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r0}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{r1} \PYG{o}{=} \PYG{n}{register}\PYG{o}{.}\PYG{n}{Register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{r2} \PYG{o}{=} \PYG{n}{register}\PYG{o}{.}\PYG{n}{Register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{r3} \PYG{o}{=} \PYG{n}{register}\PYG{o}{.}\PYG{n}{Register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r3}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{r4} \PYG{o}{=} \PYG{n}{register}\PYG{o}{.}\PYG{n}{Register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r4}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{r5} \PYG{o}{=} \PYG{n}{register}\PYG{o}{.}\PYG{n}{Register}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{r5}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{reg} \PYG{o+ow}{in} \PYG{p}{(}\PYG{n}{r0}\PYG{p}{,} \PYG{n}{r1}\PYG{p}{,} \PYG{n}{r2}\PYG{p}{,} \PYG{n}{r3}\PYG{p}{,} \PYG{n}{r4}\PYG{p}{,} \PYG{n}{r5}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{proc}\PYG{o}{.}\PYG{n}{add\PYGZus{}register}\PYG{p}{(}\PYG{n}{reg}\PYG{p}{)}
        \PYG{k}{for} \PYG{n}{command} \PYG{o+ow}{in} \PYG{n}{basic\PYGZus{}commands}\PYG{p}{:}
                \PYG{n}{proc}\PYG{o}{.}\PYG{n}{register\PYGZus{}command}\PYG{p}{(}\PYG{n}{command}\PYG{p}{)}

        \PYG{k}{return} \PYG{p}{(}\PYG{n}{proc}\PYG{p}{,} \PYG{n}{rom}\PYG{p}{,} \PYG{n}{ram}\PYG{p}{,} \PYG{n}{flash}\PYG{p}{)}
\end{Verbatim}
\index{small\_register\_machine() (in module py\_register\_machine2.machines.small)}

\begin{fulllineitems}
\phantomsection\label{machines:py_register_machine2.machines.small.small_register_machine}\pysiglinewithargsret{\code{py\_register\_machine2.machines.small.}\bfcode{small\_register\_machine}}{\emph{rom\_size=50}, \emph{ram\_size=200}, \emph{flash\_size=500}}{}
An unprogrammend Register Machine with
\begin{itemize}
\item {} 
one OutputRegister to \code{sys.stdout} (\code{out0})

\item {} 
15 General Purpose Register (\code{r0 - r14})

\end{itemize}

returns : \code{(Processor, ROM, RAM, Flash)}

\end{fulllineitems}



\chapter{Tools}
\label{tools::doc}\label{tools:tools}

\section{Basic Assembler}
\label{tools:module-py_register_machine2.tools.assembler.assembler}\label{tools:basic-assembler}\index{py\_register\_machine2.tools.assembler.assembler (module)}
\textbf{py\_register\_machine2.tools.assembler.assember}: The Basic Assembler

Just replaces mnemonics with opcodes and handles references.
\index{ArgumentError}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.ArgumentError}\pysiglinewithargsret{\strong{exception }\code{py\_register\_machine2.tools.assembler.assembler.}\bfcode{ArgumentError}}{\emph{*args}}{}~\phantomsection\label{tools:argumenterror}
Raised if an argument does not fit the requirements.

\end{fulllineitems}

\index{AssembleError}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.AssembleError}\pysiglinewithargsret{\strong{exception }\code{py\_register\_machine2.tools.assembler.assembler.}\bfcode{AssembleError}}{\emph{*args}}{}~\phantomsection\label{tools:assembleerror}
Rasied if the assemler terminates without success.

\end{fulllineitems}

\index{Assembler (class in py\_register\_machine2.tools.assembler.assembler)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.tools.assembler.assembler.}\bfcode{Assembler}}{\emph{processor, open\_stream, directives={[}{]}, commentstarts={[}';'{]}}}{}~\phantomsection\label{tools:assembler}
Reads assembly code from \code{open\_stream} and converts it to
a \code{list} of integers that can be programmed to the ROM or the Flash.

\textbf{Stages}:
\begin{description}
\item[{Split Run}] \leavevmode
Reads the complete file and converts it to a list of tuples:
\code{{[}(lineno, "command", \textless{}command\textgreater{}, arguments), ...{]}{}`} or
\code{{[}(lineno, "data", \textless{}data description\textgreater{}, data), ...{]}{}`}

\item[{Argument Run}] \leavevmode
Checks and converts the arguments. Unconvertable \code{str} objects are
interpreted as addresses.

\item[{Dereference Run}] \leavevmode
Handles references.

\item[{Program Run}] \leavevmode
Generates one iterable of integers

\end{description}
\index{add\_ref() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.add_ref}\pysiglinewithargsret{\bfcode{add\_ref}}{\emph{wordlist}}{}
Adds a reference.

\end{fulllineitems}

\index{argument\_run() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.argument_run}\pysiglinewithargsret{\bfcode{argument\_run}}{\emph{sp\_r}}{}~\phantomsection\label{tools:argument-run}
Converts Arguments according to \code{to\_int}

\end{fulllineitems}

\index{assemble() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.assemble}\pysiglinewithargsret{\bfcode{assemble}}{}{}~\phantomsection\label{tools:id1}
Chains {\hyperref[tools:split\string-run]{\emph{split\_run}}}, {\hyperref[tools:argument\string-run]{\emph{argument\_run}}}, {\hyperref[tools:dereference\string-run]{\emph{dereference\_run}}} and {\hyperref[tools:program\string-run]{\emph{program\_run}}}.

\end{fulllineitems}

\index{checkargs() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.checkargs}\pysiglinewithargsret{\bfcode{checkargs}}{\emph{lineno}, \emph{command}, \emph{args}}{}
Check if the arguments fit the requirements of the command.

Raises {\hyperref[tools:argumenterror]{\emph{ArgumentError}}}, if an argument does not fit.

\end{fulllineitems}

\index{convert\_args() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.convert_args}\pysiglinewithargsret{\bfcode{convert\_args}}{\emph{command}, \emph{args}}{}
Converts \code{str -\textgreater{} int} or \code{register -\textgreater{} int}.

\end{fulllineitems}

\index{dereference\_run() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.dereference_run}\pysiglinewithargsret{\bfcode{dereference\_run}}{\emph{arg\_r}}{}~\phantomsection\label{tools:dereference-run}
Converts the commands to opcodes and inserts the (relative or static) references.

\end{fulllineitems}

\index{getdirective() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.getdirective}\pysiglinewithargsret{\bfcode{getdirective}}{\emph{name}}{}
Returns the directive with the name \code{name}.

\end{fulllineitems}

\index{handle\_directive() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.handle_directive}\pysiglinewithargsret{\bfcode{handle\_directive}}{\emph{words}}{}
handles directives: adds the reference and allocates space for the content

\end{fulllineitems}

\index{isdirective() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.isdirective}\pysiglinewithargsret{\bfcode{isdirective}}{\emph{words}}{}
Check if the line \code{words} is a directive.

\end{fulllineitems}

\index{program\_run() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.program_run}\pysiglinewithargsret{\bfcode{program\_run}}{\emph{der\_r}}{}~\phantomsection\label{tools:program-run}
Generates an iterable that can be programmed onto the register machine.

\end{fulllineitems}

\index{split\_run() (py\_register\_machine2.tools.assembler.assembler.Assembler method)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.Assembler.split_run}\pysiglinewithargsret{\bfcode{split\_run}}{}{}~\phantomsection\label{tools:split-run}
Splits the assembly code into
\begin{itemize}
\item {} 
commands

\item {} 
directives

\item {} 
jump marks

\end{itemize}

\end{fulllineitems}


\end{fulllineitems}

\index{isreference() (in module py\_register\_machine2.tools.assembler.assembler)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.assembler.isreference}\pysiglinewithargsret{\code{py\_register\_machine2.tools.assembler.assembler.}\bfcode{isreference}}{\emph{wordlist}}{}
if the line is a reference (jump mark),
return true

\end{fulllineitems}



\section{Assembly Directives}
\label{tools:module-py_register_machine2.tools.assembler.directives}\label{tools:assembly-directives}\index{py\_register\_machine2.tools.assembler.directives (module)}\index{BaseDirective (class in py\_register\_machine2.tools.assembler.directives)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.directives.BaseDirective}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.tools.assembler.directives.}\bfcode{BaseDirective}}{\emph{name}}{}
Every Directive has to provide the following Attributes/Methods:
\begin{itemize}
\item {} 
\code{name} (like \code{.set})

\item {} 
\code{get\_words(line)}: return the data to store

\item {} 
\code{get\_word\_count(line)}: return the number of words to store

\item {} 
\code{isstatic()} returns True, if the reference should be static

\end{itemize}

\end{fulllineitems}

\index{ConvertingDirective (class in py\_register\_machine2.tools.assembler.directives)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.directives.ConvertingDirective}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.tools.assembler.directives.}\bfcode{ConvertingDirective}}{\emph{name}, \emph{function}}{}
The function \code{function} will have to take the rest of the line (as a list)
and convert it to an iterable of \code{int} objects

\textbf{Example}: The \code{.string} directive:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} usage: .string name string}
\PYG{c+c1}{\PYGZsh{} ie.: .string foo this is a test}

\PYG{k}{def} \PYG{n+nf}{string\PYGZus{}function}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{line} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{ }\PYG{l+s+s2}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{line}\PYG{p}{)}
        \PYG{n}{res} \PYG{o}{=} \PYG{p}{[}\PYG{p}{]}
        \PYG{k}{for} \PYG{n}{char} \PYG{o+ow}{in} \PYG{n}{line}\PYG{p}{:}
                \PYG{n}{res}\PYG{o}{.}\PYG{n}{append}\PYG{p}{(}\PYG{n+nb}{ord}\PYG{p}{(}\PYG{n}{char}\PYG{p}{)}\PYG{p}{)}
        \PYG{k}{return} \PYG{n}{res}
\end{Verbatim}

\end{fulllineitems}

\index{Padding (class in py\_register\_machine2.tools.assembler.directives)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.directives.Padding}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.tools.assembler.directives.}\bfcode{Padding}}{\emph{name='.padd'}}{}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
.padd name n v
\end{Verbatim}

Fills the next n words with v.

\end{fulllineitems}

\index{Zeros (class in py\_register\_machine2.tools.assembler.directives)}

\begin{fulllineitems}
\phantomsection\label{tools:py_register_machine2.tools.assembler.directives.Zeros}\pysiglinewithargsret{\strong{class }\code{py\_register\_machine2.tools.assembler.directives.}\bfcode{Zeros}}{\emph{name='.zeros'}}{}
Usage:

\begin{Verbatim}[commandchars=\\\{\}]
.zeros name n   
\end{Verbatim}

Fills the next n words with zeros.

\end{fulllineitems}



\chapter{Developer's Guide}
\label{developer_guide::doc}\label{developer_guide:developer-s-guide}

\section{Contributing}
\label{developer_guide:contributing}
Because PyRegisterMachine2 is GPL'ed everybody is able to modify the code and
redistribute the (modified) code, according to the GNU GPL v3.

If you want to share your changes on the main branch, just send a pull request (via GitHub).


\section{Engine Tools}
\label{developer_guide:engine-tools}

\subsection{Conversions}
\label{developer_guide:conversions}\label{developer_guide:module-py_register_machine2.engine_tools.conversions}\index{py\_register\_machine2.engine\_tools.conversions (module)}
A collection of conversion functions/generators.
\index{bytes\_to\_int() (in module py\_register\_machine2.engine\_tools.conversions)}

\begin{fulllineitems}
\phantomsection\label{developer_guide:py_register_machine2.engine_tools.conversions.bytes_to_int}\pysiglinewithargsret{\code{py\_register\_machine2.engine\_tools.conversions.}\bfcode{bytes\_to\_int}}{\emph{bytes\_}, \emph{width=None}}{}~\phantomsection\label{developer_guide:bytes-to-int}
Converts the \code{bytes} object \code{bytes\_} to an \code{int}.
If \code{width} is none, \code{width = len(byte\_) * 8} is choosen.

See also: {\hyperref[developer_guide:int\string-to\string-bytes]{\emph{int\_to\_bytes}}}

\emph{Example}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.engine\PYGZus{}tools.conversions} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{i} \PYG{o}{=} \PYG{l+m+mi}{4012}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{int\PYGZus{}to\PYGZus{}bytes}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}
\PYG{g+go}{b\PYGZsq{}\PYGZsq{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bytes\PYGZus{}to\PYGZus{}int}\PYG{p}{(}\PYG{n}{int\PYGZus{}to\PYGZus{}bytes}\PYG{p}{(}\PYG{n}{i}\PYG{p}{)}\PYG{p}{)} \PYG{o}{==} \PYG{n}{i}
\PYG{g+go}{True}
\end{Verbatim}

\end{fulllineitems}

\index{int\_to\_bytes() (in module py\_register\_machine2.engine\_tools.conversions)}

\begin{fulllineitems}
\phantomsection\label{developer_guide:py_register_machine2.engine_tools.conversions.int_to_bytes}\pysiglinewithargsret{\code{py\_register\_machine2.engine\_tools.conversions.}\bfcode{int\_to\_bytes}}{\emph{int\_}, \emph{width=None}}{}~\phantomsection\label{developer_guide:int-to-bytes}
Converts the \code{int} \code{int\_} to a \code{bytes} object.
\code{len(result) == width}.

If \code{width} is None, a number of bytes that is able to hold the
number is choosen, depending on \code{int\_.bit\_length()}.

See also: {\hyperref[developer_guide:bytes\string-to\string-int]{\emph{bytes\_to\_int}}}

\end{fulllineitems}

\index{to\_int() (in module py\_register\_machine2.engine\_tools.conversions)}

\begin{fulllineitems}
\phantomsection\label{developer_guide:py_register_machine2.engine_tools.conversions.to_int}\pysiglinewithargsret{\code{py\_register\_machine2.engine\_tools.conversions.}\bfcode{to\_int}}{\emph{argument}}{}
Converts the \code{str} argument to an integer:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.engine\PYGZus{}tools.conversions} \PYG{k+kn}{import} \PYG{o}{*}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{to\PYGZus{}int}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{0x04}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{4}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{to\PYGZus{}int}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{a}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{g+go}{97}
\end{Verbatim}

\end{fulllineitems}



\subsection{Operations}
\label{developer_guide:operations}\label{developer_guide:module-py_register_machine2.engine_tools.operations}\index{py\_register\_machine2.engine\_tools.operations (module)}
Operations used by the engine.
\index{bitsetxor() (in module py\_register\_machine2.engine\_tools.operations)}

\begin{fulllineitems}
\phantomsection\label{developer_guide:py_register_machine2.engine_tools.operations.bitsetxor}\pysiglinewithargsret{\code{py\_register\_machine2.engine\_tools.operations.}\bfcode{bitsetxor}}{\emph{b1}, \emph{b2}}{}
If b1 and b2 would be \code{int} s this would be \code{b1 \textasciicircum{} b2} :

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{py\PYGZus{}register\PYGZus{}machine2.engine\PYGZus{}tools.operations} \PYG{k+kn}{import} \PYG{n}{bitsetxor}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b1} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{b2} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mi}{0}\PYG{p}{,} \PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bitsetxor}\PYG{p}{(}\PYG{n}{b1}\PYG{p}{,} \PYG{n}{b2}\PYG{p}{)}
\PYG{g+go}{[0, 0, 1, 0]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n+nb}{bin}\PYG{p}{(}\PYG{l+m+mb}{0b1111} \PYG{o}{\PYGZca{}} \PYG{l+m+mb}{0b1101}\PYG{p}{)}
\PYG{g+go}{\PYGZsq{}0b10\PYGZsq{}}
\end{Verbatim}

\end{fulllineitems}



\chapter{Installing PyRegisterMachine2}
\label{install::doc}\label{install:installing-pyregistermachine2}

\section{From Source}
\label{install:from-source}
PyRegisterMachine2 is a simple python3-package, so the only thing one has to do is to place the folder in the \code{\$PYTHONPATH}. One can get the \code{\$PYTHONPATH} in the following ways:

\begin{Verbatim}[commandchars=\\\{\}]
echo \PYGZdl{}PYTHONPATH
python3 \PYGZhy{}c \PYGZdq{}import sys; print(sys.path)\PYGZdq{}
\end{Verbatim}
\begin{itemize}
\item {} 
Local Installation

\end{itemize}

Usually the local path is \code{/home/\textless{}username\textgreater{}/.local/lib/python3.5/site-packages}, so you are able to install the package via git:

\begin{Verbatim}[commandchars=\\\{\}]
cd /home/daniel/.local/lib/python3.5/site\PYGZhy{}packages
git clone https://github.com/daknuett/py\PYGZus{}register\PYGZus{}machine2
\end{Verbatim}
\begin{itemize}
\item {} 
Global Installation:

\begin{Verbatim}[commandchars=\\\{\}]
cd /usr/local/lib/python3.5/dist\PYGZhy{}packages
git clone https://github.com/daknuett/py\PYGZus{}register\PYGZus{}machine2
\end{Verbatim}

\end{itemize}


\section{Using PyPi}
\label{install:using-pypi}
Use

\begin{Verbatim}[commandchars=\\\{\}]
python3 \PYGZhy{}m pip install py\PYGZus{}register\PYGZus{}machine2
\end{Verbatim}

To install py\_register\_machine2 using PyPi.


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{p}
\item {\texttt{py\_register\_machine2.commands.basic\_commands}}, \pageref{commands:module-py_register_machine2.commands.basic_commands}
\item {\texttt{py\_register\_machine2.commands.stack\_based}}, \pageref{commands:module-py_register_machine2.commands.stack_based}
\item {\texttt{py\_register\_machine2.core.commands}}, \pageref{core:module-py_register_machine2.core.commands}
\item {\texttt{py\_register\_machine2.core.device}}, \pageref{core:module-py_register_machine2.core.device}
\item {\texttt{py\_register\_machine2.core.interrupts}}, \pageref{core:module-py_register_machine2.core.interrupts}
\item {\texttt{py\_register\_machine2.core.memory}}, \pageref{core:module-py_register_machine2.core.memory}
\item {\texttt{py\_register\_machine2.core.parts}}, \pageref{core:module-py_register_machine2.core.parts}
\item {\texttt{py\_register\_machine2.core.processor}}, \pageref{core:module-py_register_machine2.core.processor}
\item {\texttt{py\_register\_machine2.core.register}}, \pageref{core:module-py_register_machine2.core.register}
\item {\texttt{py\_register\_machine2.engine\_tools.conversions}}, \pageref{developer_guide:module-py_register_machine2.engine_tools.conversions}
\item {\texttt{py\_register\_machine2.engine\_tools.operations}}, \pageref{developer_guide:module-py_register_machine2.engine_tools.operations}
\item {\texttt{py\_register\_machine2.machines.small}}, \pageref{machines:module-py_register_machine2.machines.small}
\item {\texttt{py\_register\_machine2.tools.assembler.assembler}}, \pageref{tools:module-py_register_machine2.tools.assembler.assembler}
\item {\texttt{py\_register\_machine2.tools.assembler.directives}}, \pageref{tools:module-py_register_machine2.tools.assembler.directives}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
